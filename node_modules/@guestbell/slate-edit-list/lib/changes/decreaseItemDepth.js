"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var slate_1 = require("slate");
var utils_1 = require("../utils");
/**
 * Decreases the depth of the current item. The following items will
 * be moved as subList of the decreased item.
 *
 * No-op for root items.
 */
function decreaseItemDepth(opts, editor) {
    var value = editor.value;
    var document = value.document;
    // Cannot decrease item depth of root items
    var depth = utils_1.getItemDepth(opts)(value);
    if (depth === 1) {
        return editor;
    }
    var currentItem = utils_1.getCurrentItem(opts)(value);
    if (!currentItem) {
        return editor;
    }
    var currentList = document.getParent(currentItem.key);
    var parentItem = document.getParent(currentList.key);
    var parentList = document.getParent(parentItem.key);
    // The items following the item will be moved to a subList of currentItem
    var followingItems = currentList.nodes
        .skipUntil(function (i) { return i === currentItem; })
        .rest();
    // True if the currentItem and the followingItems make the whole
    // currentList, and hence the currentList will be emptied
    var willEmptyCurrentList = currentList.nodes.size === followingItems.size + 1;
    if (!followingItems.isEmpty()) {
        // Add them as subList of currentItem
        var subList_1 = slate_1.Block.create({
            object: 'block',
            type: currentList.type,
            data: currentList.data,
        });
        // Add the subList
        editor.withoutNormalizing(function () {
            editor.insertNodeByKey(currentItem.key, currentItem.nodes.size, subList_1);
        });
        editor.withoutNormalizing(function () {
            editor.moveNodeByKey(currentItem.key, parentList.key, parentList.nodes.indexOf(parentItem) + 1);
        });
        // Move the followingItems to the subList
        followingItems.forEach(function (item, index) {
            editor.withoutNormalizing(function () {
                editor.moveNodeByKey(item.key, subList_1.key, subList_1.nodes.size + index);
            });
        });
    }
    else {
        editor.moveNodeByKey(currentItem.key, parentList.key, parentList.nodes.indexOf(parentItem) + 1);
    }
    // Remove the currentList completely if needed
    if (willEmptyCurrentList) {
        editor.removeNodeByKey(currentList.key);
    }
    return editor;
}
exports.default = decreaseItemDepth;
//# sourceMappingURL=decreaseItemDepth.js.map