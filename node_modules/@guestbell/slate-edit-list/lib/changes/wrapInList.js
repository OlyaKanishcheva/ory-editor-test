"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var slate_1 = require("slate");
var immutable_1 = require("immutable");
var utils_1 = require("../utils");
/**
 * Wrap the blocks in the current selection in a new list. Selected
 * lists are merged together.
 */
var wrapInList = function (opts) { return function (editor, type, data) {
    var selectedBlocks = getHighestSelectedBlocks(editor.value);
    type = type || opts.types[0];
    // Wrap in container
    editor.withoutNormalizing(function () {
        editor.wrapBlock({
            type: type,
            data: slate_1.Data.create(data),
        });
    });
    // Wrap in list items
    selectedBlocks.forEach(function (node) {
        if (utils_1.isList(opts)(node)) {
            // Merge its items with the created list
            node.nodes.forEach(function (_a) {
                var key = _a.key;
                editor.withoutNormalizing(function () {
                    editor.unwrapNodeByKey(key);
                });
            });
        }
        else {
            editor.withoutNormalizing(function () {
                editor.wrapBlockByKey(node.key, opts.typeItem);
            });
        }
    });
    return editor.normalize();
}; };
/**
 * Returns the highest list of blocks that cover the current selection
 */
function getHighestSelectedBlocks(value) {
    var range = value.selection;
    var document = value.document;
    var startBlock = document.getClosestBlock(range.start.key);
    var endBlock = document.getClosestBlock(range.end.key);
    if (startBlock === endBlock) {
        return immutable_1.List([startBlock]);
    }
    var ancestor = document.getCommonAncestor(startBlock.key, endBlock.key);
    var startPath = ancestor.getPath(startBlock.key);
    var endPath = ancestor.getPath(endBlock.key);
    return ancestor.nodes.slice(startPath[0], endPath[0] + 1);
}
exports.default = wrapInList;
//# sourceMappingURL=wrapInList.js.map