"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var slate_1 = require("slate");
/**
 * Create a schema definition with rules to normalize blockquotes
 */
function schema(opts) {
    var _a;
    return {
        blocks: (_a = {},
            _a[opts.type] = {
                nodes: [
                    {
                        match: { type: opts.typeDefault },
                    },
                ],
                // tslint:disable-next-line:no-any
                normalize: function (editor, error) {
                    switch (error.code) {
                        case 'child_type_invalid':
                            return containBlocks(opts, editor, error);
                        default:
                            break;
                    }
                },
            },
            _a),
    };
}
/**
 *  Ensures that blockquotes always contain blocks.
 */
function containBlocks(opts, editor, 
// tslint:disable-next-line:no-any
context) {
    var toWrap = context.node.nodes.filter(function (n) { return n.object !== 'block'; });
    if (toWrap.isEmpty()) {
        return undefined;
    }
    // Wrap text/inline nodes in default block
    var wrapper = slate_1.Block.create({ type: opts.typeDefault });
    return editor.withoutNormalizing(function () {
        editor.insertNodeByKey(context.node.key, 0, wrapper);
        toWrap.forEach(function (child, index) {
            // this was use to determine normalization (isLast === false => normalize: false)
            // const isLast = index === toWrap.size - 1;
            editor.moveNodeByKey(child.key, wrapper.key, index);
        });
    });
}
exports.default = schema;
//# sourceMappingURL=schema.js.map