{"ast":null,"code":"\"use strict\";\n/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar immutable_1 = require(\"immutable\");\n\nvar head_1 = __importDefault(require(\"ramda/src/head\"));\n\nvar map_1 = __importDefault(require(\"ramda/src/map\"));\n\nvar path_1 = __importDefault(require(\"ramda/src/path\"));\n\nvar reduce_1 = __importDefault(require(\"ramda/src/reduce\"));\n\nvar tail_1 = __importDefault(require(\"ramda/src/tail\"));\n\nvar react_1 = __importDefault(require(\"react\"));\n\nvar alignment_1 = __importDefault(require(\"./plugins/alignment\"));\n\nvar blockquote_1 = __importDefault(require(\"./plugins/blockquote\"));\n\nvar index_1 = __importDefault(require(\"./plugins/code/index\"));\n\nvar emphasize_1 = __importDefault(require(\"./plugins/emphasize\"));\n\nvar headings_1 = __importDefault(require(\"./plugins/headings\"));\n\nvar index_2 = __importDefault(require(\"./plugins/link/index\"));\n\nvar lists_1 = __importDefault(require(\"./plugins/lists\"));\n\nvar index_3 = __importStar(require(\"./plugins/paragraph/index\"));\n\nvar parse5_1 = __importDefault(require(\"parse5\")); // FIXME #126\n\n\nvar slate_1 = require(\"slate\");\n\nvar slate_html_serializer_1 = __importDefault(require(\"slate-html-serializer\"));\n\nvar slate_plain_serializer_1 = __importDefault(require(\"slate-plain-serializer\"));\n\nvar DEFAULT_NODE = index_3.P;\nexports.defaultPlugins = [new index_3.default(), new emphasize_1.default(), new headings_1.default({\n  DEFAULT_NODE: DEFAULT_NODE\n}), new index_2.default(), new index_1.default({\n  DEFAULT_NODE: DEFAULT_NODE\n}), new lists_1.default({\n  DEFAULT_NODE: DEFAULT_NODE\n}), new blockquote_1.default({\n  DEFAULT_NODE: DEFAULT_NODE\n}), new alignment_1.default({\n  DEFAULT_NODE: DEFAULT_NODE\n})];\nexports.lineBreakSerializer = {\n  // tslint:disable-next-line:no-any\n  deserialize: function deserialize(el) {\n    if (el.tagName.toLowerCase() === 'br') {\n      return {\n        object: 'text',\n        text: '\\n'\n      };\n    }\n\n    if (el.nodeName === '#text') {\n      if (el.value && el.value.match(/<!--.*?-->/)) {\n        return;\n      }\n\n      return {\n        object: 'text',\n        leaves: [{\n          object: 'leaf',\n          text: el.value\n        }]\n      };\n    }\n  },\n  // tslint:disable-next-line:no-any\n  serialize: function serialize(object, children) {\n    if (object.type === 'text' || children === '\\n') {\n      return react_1.default.createElement(\"br\", null);\n    }\n  }\n};\nexports.html = new slate_html_serializer_1.default({\n  rules: exports.defaultPlugins.concat([exports.lineBreakSerializer]),\n  parseHtml: parse5_1.default.parseFragment\n});\n\nexports.createInitialState = function () {\n  return {\n    editorState: slate_1.Value.fromJSON({\n      document: {\n        nodes: [{\n          object: 'block',\n          type: index_3.P,\n          nodes: [{\n            object: 'text',\n            leaves: [{\n              text: ''\n            }]\n          }]\n        }]\n      }\n    })\n  };\n};\n\nexports.unserialize = function (_a) {\n  var importFromHtml = _a.importFromHtml,\n      serialized = _a.serialized,\n      editorState = _a.editorState;\n\n  if (serialized) {\n    // tslint:disable-next-line:no-any\n    return {\n      editorState: slate_1.Value.fromJSON(serialized)\n    };\n  } else if (importFromHtml) {\n    return {\n      editorState: exports.html.deserialize(importFromHtml)\n    };\n  } else if (editorState) {\n    return {\n      editorState: editorState\n    };\n  }\n\n  return exports.createInitialState();\n}; // tslint:disable-next-line:no-any\n\n\nexports.serialize = function (_a) {\n  var editorState = _a.editorState;\n  return {\n    // tslint:disable-next-line:no-any\n    serialized: editorState.toJSON(editorState)\n  };\n};\n\nexports.merge = function (states) {\n  var nodes = map_1.default(path_1.default(['editorState', 'document', 'nodes']), states);\n  var mergedNodes = reduce_1.default( // tslint:disable-next-line:no-any\n  function (a, b) {\n    return a.concat(b);\n  }, head_1.default(nodes), tail_1.default(nodes));\n  var mergedDocument = slate_1.Document.create({\n    nodes: mergedNodes\n  });\n  var mergedEditorState = slate_1.Value.create({\n    document: mergedDocument\n  });\n  return {\n    editorState: mergedEditorState\n  };\n};\n\nexports.split = function (state) {\n  var nodes = path_1.default(['editorState', 'document', 'nodes'], state);\n  return nodes ? nodes.toArray().map(function (node) {\n    var splittedDocument = slate_1.Document.create({\n      nodes: immutable_1.List([node])\n    });\n    var splittedEditorState = slate_1.Value.create({\n      document: splittedDocument\n    });\n    return {\n      editorState: splittedEditorState\n    };\n  }) : [];\n}; // const position = (): {\n//   top: ?number,\n//   right: ?number,\n//   left: ?number,\n//   bottom: ?number\n// } => {\n//   if (window && window.getSelection) {\n//     const selection = window.getSelection()\n//     if (!selection.rangeCount) {\n//       return {\n//         top: null,\n//         right: null,\n//         left: null,\n//         bottom: null,\n//       }\n//     }\n//\n//     return selection.getRangeAt(0).getBoundingClientRect()\n//   }\n//\n//   if (window.document.selection) {\n//     return window.document.selection\n//       .createRange()\n//       .getBoundingClientRect()\n//   }\n//\n//   return {\n//     top: null,\n//     right: null,\n//     left: null,\n//     bottom: null,\n//   }\n// }\n// if editor state is empty, remove cell when backspace or delete was pressed.\n\n\nexports.handleRemoveHotKey = function (_, _a) {\n  var editorState = _a.content.state.editorState;\n  return new Promise(function (resolve, reject) {\n    return slate_plain_serializer_1.default.serialize(editorState).length < 1 ? resolve() : reject();\n  });\n};\n\nvar windowSelectionWaitTime = 1;\n\nexports.handleFocusPreviousHotKey = function (e, _a) {\n  // const isArrowUp = e.keyCode === 38\n  var editorState = _a.content.state.editorState;\n  return new Promise(function (resolve, reject) {\n    if (editorState.selection.isExpanded) {\n      return reject();\n    }\n\n    setTimeout(function () {\n      // if (isArrowUp && next.top === current.top) {\n      //   return resolve()\n      // } else\n      if (editorState.selection.isCollapsed && editorState.selection.anchor.isAtStartOfNode(editorState.document.nodes.first())) {\n        return resolve();\n      }\n\n      reject();\n    }, windowSelectionWaitTime);\n  });\n};\n\nexports.handleFocusNextHotKey = function (e, _a) {\n  // const isArrowDown = e.keyCode === 40\n  var editorState = _a.content.state.editorState;\n  return new Promise(function (resolve, reject) {\n    if (editorState.selection.isExpanded) {\n      return reject();\n    }\n\n    setTimeout(function () {\n      // if (isArrowDown && next.top === current.top) {\n      //   return resolve()\n      // } else\n      if (editorState.selection.isCollapsed && editorState.selection.anchor.isAtEndOfNode(editorState.document.nodes.last())) {\n        return resolve();\n      }\n\n      reject();\n    }, windowSelectionWaitTime);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}