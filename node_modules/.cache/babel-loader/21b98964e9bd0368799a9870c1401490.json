{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = undoable;\n\nvar _debug = require('./debug');\n\nvar debug = _interopRequireWildcard(_debug);\n\nvar _actions = require('./actions');\n\nvar _helpers = require('./helpers');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // lengthWithoutFuture: get length of history\n\n\nfunction lengthWithoutFuture(history) {\n  return history.past.length + 1;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit) {\n  debug.log('inserting', state);\n  debug.log('new free: ', limit - lengthWithoutFuture(history));\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var historyOverflow = limit && lengthWithoutFuture(history) >= limit;\n  var pastSliced = past.slice(historyOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return {\n    past: newPast,\n    present: state,\n    _latestUnfiltered: state,\n    future: []\n  };\n} // undo: go back to the previous point in history\n\n\nfunction undo(history) {\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  if (past.length <= 0) return history;\n  var newFuture = _latestUnfiltered != null ? [_latestUnfiltered].concat(_toConsumableArray(future)) : future;\n  var newPresent = past[past.length - 1];\n  return {\n    past: past.slice(0, past.length - 1),\n    // remove last element from past\n    present: newPresent,\n    // set element as new present\n    _latestUnfiltered: newPresent,\n    future: newFuture\n  };\n} // redo: go to the next point in history\n\n\nfunction redo(history) {\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  if (future.length <= 0) return history;\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(past), [_latestUnfiltered]) : past;\n  var newPresent = future[0];\n  return {\n    future: future.slice(1, future.length),\n    // remove element from future\n    present: newPresent,\n    // set element as new present\n    _latestUnfiltered: newPresent,\n    past: newPast\n  };\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index === 0) return redo(history);\n  if (index < 0 || index >= history.future.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPresent = future[index];\n  return {\n    future: future.slice(index + 1),\n    present: newPresent,\n    _latestUnfiltered: newPresent,\n    past: past.concat([_latestUnfiltered]).concat(future.slice(0, index))\n  };\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index === history.past.length - 1) return undo(history);\n  if (index < 0 || index >= history.past.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPresent = past[index];\n  return {\n    future: past.slice(index + 1).concat([_latestUnfiltered]).concat(future),\n    present: newPresent,\n    _latestUnfiltered: newPresent,\n    past: past.slice(0, index)\n  };\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) return jumpToFuture(history, n - 1);\n  if (n < 0) return jumpToPast(history, history.past.length + n);\n  return history;\n} // createHistory\n\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  return ignoreInitialState ? {\n    past: [],\n    present: state,\n    future: []\n  } : {\n    past: [],\n    present: state,\n    _latestUnfiltered: state,\n    future: []\n  };\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n  var config = {\n    initTypes: (0, _helpers.parseActions)(rawConfig.initTypes, ['@@redux-undo/INIT']),\n    limit: rawConfig.limit,\n    filter: rawConfig.filter || function () {\n      return true;\n    },\n    undoType: rawConfig.undoType || _actions.ActionTypes.UNDO,\n    redoType: rawConfig.redoType || _actions.ActionTypes.REDO,\n    jumpToPastType: rawConfig.jumpToPastType || _actions.ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: rawConfig.jumpToFutureType || _actions.ActionTypes.JUMP_TO_FUTURE,\n    jumpType: rawConfig.jumpType || _actions.ActionTypes.JUMP,\n    clearHistoryType: Array.isArray(rawConfig.clearHistoryType) ? rawConfig.clearHistoryType : [rawConfig.clearHistoryType || _actions.ActionTypes.CLEAR_HISTORY],\n    neverSkipReducer: rawConfig.neverSkipReducer || false,\n    ignoreInitialState: rawConfig.ignoreInitialState || false\n  };\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.history;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    debug.start(action, state);\n    var history = state;\n\n    if (!config.history) {\n      debug.log('history is uninitialized');\n\n      if (state === undefined) {\n        history = config.history = createHistory(reducer(state, {\n          type: '@@redux-undo/CREATE_HISTORY'\n        }), config.ignoreInitialState);\n        debug.log('do not initialize on probe actions');\n      } else if ((0, _helpers.isHistory)(state)) {\n        history = config.history = config.ignoreInitialState ? state : _extends({}, state, {\n          _latestUnfiltered: state.present\n        });\n        debug.log('initialHistory initialized: initialState is a history', config.history);\n      } else {\n        history = config.history = createHistory(state);\n        debug.log('initialHistory initialized: initialState is not a history', config.history);\n      }\n    }\n\n    var skipReducer = function skipReducer(res) {\n      return config.neverSkipReducer ? _extends({}, res, {\n        present: reducer(res.present, action)\n      }) : res;\n    };\n\n    var res = void 0;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = undo(history);\n        debug.log('perform undo');\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.redoType:\n        res = redo(history);\n        debug.log('perform redo');\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log('perform jumpToPast to ' + action.index);\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log('perform jumpToFuture to ' + action.index);\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log('perform jump to ' + action.index);\n        debug.end(res);\n        return skipReducer(res);\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present);\n        debug.log('perform clearHistory');\n        debug.end(res);\n        return skipReducer(res);\n\n      default:\n        res = reducer(history.present, action);\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log('reset history due to init action');\n          debug.end(config.history);\n          return config.history;\n        }\n\n        if (history.present === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n\n        if (typeof config.filter === 'function' && !config.filter(action, res, history)) {\n          // if filtering an action, merely update the present\n          var nextState = _extends({}, history, {\n            present: res\n          });\n\n          debug.log('filter prevented action, not storing it');\n          debug.end(nextState);\n          return nextState;\n        } else {\n          // If the action wasn't filtered, insert normally\n          history = insert(history, res, config.limit);\n          debug.log('inserted new state into history');\n          debug.end(history);\n          return history;\n        }\n\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}