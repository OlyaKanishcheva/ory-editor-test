{"ast":null,"code":"\"use strict\";\n/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MAX_CELLS_PER_ROW = 12;\n/**\n * Sum up cell sizes: Î£(cell[size]).\n */\n\nexports.sumSizes = function (cells) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  return cells.reduce( // tslint:disable-next-line:no-any\n  function (_a, _b) {\n    var _c = _a.size,\n        p = _c === void 0 ? 99 : _c,\n        a = _a.inline;\n    var _d = _b.size,\n        c = _d === void 0 ? 99 : _d,\n        b = _b.inline;\n    return {\n      size: (a ? 0 : 1) * p + (b ? 0 : 1) * c\n    };\n  }, {\n    size: 0\n  }).size;\n};\n/**\n * Updates each cell's size boundaries.\n */\n\n\nexports.computeBounds = function (cells) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  return cells.map(function (c, k) {\n    return __assign({}, c, {\n      bounds: {\n        left: k > 0 ? cells[k - 1].size + c.size - 1 : 0,\n        right: k === cells.length - 1 ? 0 : c.size - 1 + cells[k + 1].size\n      }\n    });\n  });\n};\n/**\n * Computes if a cell is resizable.\n */\n\n\nexports.computeResizeable = function (cells) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  return cells.map(function (c, k) {\n    return __assign({}, c, {\n      resizable: cells.length > 1 && k !== cells.length - 1\n    });\n  });\n};\n/**\n * Computes sizes an inline element was found.\n */\n\n\nexports.computeInlines = function (cells) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  if (cells.length !== 2 || !cells[0].inline) {\n    return cells.map(function (c) {\n      return __assign({}, c, {\n        inline: null,\n        hasInlineNeighbour: null\n      });\n    });\n  }\n\n  var inline = cells[0].inline;\n  return [__assign({}, cells[0], {\n    resizable: true,\n    size: cells[0].size || Math.round(MAX_CELLS_PER_ROW / 2),\n    bounds: {\n      left: inline === 'left' ? 0 : MAX_CELLS_PER_ROW - 1,\n      right: inline === 'right' ? 0 : MAX_CELLS_PER_ROW - 1\n    }\n  }), __assign({}, cells[1], {\n    bounds: {\n      left: 0,\n      right: 0\n    },\n    size: 12,\n    hasInlineNeighbour: cells[0].id\n  })];\n};\n/**\n * Resize cells.\n */\n\n\nexports.resizeCells = function (cells, _a) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  var id = _a.id,\n      size = _a.size;\n  var prev = 0;\n  return cells.map(function (c) {\n    if (prev > 0) {\n      var ret = __assign({}, c, {\n        size: c.size + prev - size\n      });\n\n      prev = 0;\n      return ret;\n    } else if (id === c.id) {\n      if (!c.inline) {\n        prev = c.size;\n      }\n\n      return __assign({}, c, {\n        size: size\n      });\n    }\n\n    return c;\n  });\n};\n/**\n * Balance cell sizes.\n *\n * @param {[...cell]} cells\n * @return {[...cell]}\n */\n\n\nexports.computeSizes = function (cells) {\n  if (cells === void 0) {\n    cells = [];\n  }\n\n  var total = exports.sumSizes(cells);\n\n  if (total === MAX_CELLS_PER_ROW) {\n    return cells;\n  }\n\n  var count = cells.length;\n  var sizePerCell = Math.floor(MAX_CELLS_PER_ROW / count);\n  var spaceLeft = MAX_CELLS_PER_ROW - sizePerCell * (count - 1);\n  return cells.map(function (c, k) {\n    return __assign({}, c, {\n      size: k === count - 1 ? spaceLeft : sizePerCell\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}