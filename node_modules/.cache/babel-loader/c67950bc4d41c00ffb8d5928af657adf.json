{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_throttle_1 = __importDefault(require(\"lodash.throttle\"));\n\nvar pathOr_1 = __importDefault(require(\"ramda/src/pathOr\"));\n\nvar input_1 = require(\"../../../../service/hover/input\");\n\nvar throttle_1 = require(\"../../../../helper/throttle\");\n\nvar logger_1 = __importDefault(require(\"../../../../service/logger\"));\n\nvar nativeDragHelpers_1 = require(\"../../../../helper/nativeDragHelpers\");\n\nvar last = {\n  hover: '',\n  drag: ''\n};\n\nvar clear = function clear(hover, drag) {\n  if (hover.id === last.hover && drag === last.drag) {\n    return;\n  }\n\n  last = {\n    hover: hover.id,\n    drag: drag\n  };\n  hover.clearHover();\n};\n\nexports.target = {\n  hover: lodash_throttle_1.default(function (hover, monitor, component) {\n    // tslint:disable-next-line:no-any\n    var drag = monitor.getItem();\n\n    if (!drag) {\n      // item undefined, happens when throttle triggers after drop\n      return;\n    }\n\n    if (nativeDragHelpers_1.isNativeHTMLElementDrag(monitor)) {\n      drag = nativeDragHelpers_1.createNativeCellReplacement();\n    }\n\n    if (drag.id === hover.id) {\n      // If hovering over itself, do nothing\n      clear(hover, drag.id);\n      return;\n    } else if (!monitor.isOver({\n      shallow: true\n    })) {\n      // If hovering over ancestor cell, do nothing (we are going to propagate later in the tree anyways)\n      return;\n    } else if (hover.ancestors.indexOf(drag.id) > -1) {\n      // If hovering over a child of itself\n      clear(hover, drag.id);\n      return;\n    } else if (!hover.id) {\n      // If hovering over something that isn't a cell or hasn't an id, do nothing. Should be an edge case\n      logger_1.default.warn('Canceled cell drop, no id given.', hover, drag);\n      return;\n    }\n\n    last = {\n      hover: hover.id,\n      drag: drag.id\n    };\n    var allowInlineNeighbours = pathOr_1.default(false, ['node', 'content', 'plugin', 'allowInlineNeighbours'], hover);\n    input_1.computeAndDispatchHover(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n  }, throttle_1.delay, {\n    leading: false\n  }),\n  canDrop: function canDrop(_a, monitor) {\n    var id = _a.id,\n        ancestors = _a.ancestors;\n    var item = monitor.getItem();\n    return item.id !== id && ancestors.indexOf(item.id) === -1;\n  },\n  // tslint:disable-next-line:no-any\n  drop: function drop(hover, monitor, component) {\n    var drag = monitor.getItem();\n\n    if (nativeDragHelpers_1.isNativeHTMLElementDrag(monitor)) {\n      var plugins = component.props.config.plugins;\n      drag = plugins.createNativePlugin(hover, monitor, component);\n    }\n\n    if (monitor.didDrop() || !monitor.isOver({\n      shallow: true\n    })) {\n      // If the item drop occurred deeper down the tree, don't do anything\n      return;\n    } else if (drag.id === hover.id) {\n      // If the item being dropped on itself do nothing\n      hover.cancelCellDrag();\n      return;\n    } else if (hover.ancestors.indexOf(drag.id) > -1) {\n      // If hovering over a child of itself, don't propagate further\n      hover.cancelCellDrag();\n      return;\n    }\n\n    last = {\n      hover: hover.id,\n      drag: drag.id\n    };\n    var allowInlineNeighbours = pathOr_1.default(false, ['node', 'content', 'plugin', 'allowInlineNeighbours'], hover);\n    input_1.computeAndDispatchInsert(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n  }\n};\n\nexports.connect = function (connectInner, monitor) {\n  return {\n    connectDropTarget: connectInner.dropTarget(),\n    isOver: monitor.isOver(),\n    isOverCurrent: monitor.isOver({\n      shallow: true\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}