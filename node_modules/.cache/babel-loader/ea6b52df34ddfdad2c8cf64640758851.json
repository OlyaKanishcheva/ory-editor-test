{"ast":null,"code":"import React from 'react';\nimport { renderToStaticMarkup } from 'react-dom/server';\nimport typeOf from 'type-of';\nimport { Node, Value } from 'slate';\nimport { Record } from 'immutable';\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * String.\n *\n * @type {String}\n */\n\n\nvar String = new Record({\n  object: 'string',\n  text: ''\n});\n/**\n * A rule to (de)serialize text nodes. This is automatically added to the HTML\n * serializer so that users don't have to worry about text-level serialization.\n *\n * @type {Object}\n */\n\nvar TEXT_RULE = {\n  deserialize: function deserialize(el) {\n    if (el.tagName && el.tagName.toLowerCase() === 'br') {\n      return {\n        object: 'text',\n        leaves: [{\n          object: 'leaf',\n          text: '\\n'\n        }]\n      };\n    }\n\n    if (el.nodeName == '#text') {\n      if (el.nodeValue && el.nodeValue.match(/<!--.*?-->/)) return;\n      return {\n        object: 'text',\n        leaves: [{\n          object: 'leaf',\n          text: el.nodeValue\n        }]\n      };\n    }\n  },\n  serialize: function serialize(obj, children) {\n    if (obj.object === 'string') {\n      return children.split('\\n').reduce(function (array, text, i) {\n        if (i != 0) array.push(React.createElement('br', {\n          key: i\n        }));\n        array.push(text);\n        return array;\n      }, []);\n    }\n  }\n};\n/**\n * A default `parseHtml` function that returns the `<body>` using `DOMParser`.\n *\n * @param {String} html\n * @return {Object}\n */\n\nfunction defaultParseHtml(html) {\n  if (typeof DOMParser === 'undefined') {\n    throw new Error('The native `DOMParser` global which the `Html` serializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.');\n  }\n\n  var parsed = new DOMParser().parseFromString(html, 'text/html');\n  var body = parsed.body; // COMPAT: in IE 11 body is null if html is an empty string\n\n  return body || window.document.createElement('body');\n}\n/**\n * HTML serializer.\n *\n * @type {Html}\n */\n\n\nvar Html =\n/**\n * Create a new serializer with `rules`.\n *\n * @param {Object} options\n *   @property {Array} rules\n *   @property {String|Object|Block} defaultBlock\n *   @property {Function} parseHtml\n */\nfunction Html() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  classCallCheck(this, Html);\n\n  _initialiseProps.call(this);\n\n  var _options$defaultBlock = options.defaultBlock,\n      defaultBlock = _options$defaultBlock === undefined ? 'paragraph' : _options$defaultBlock,\n      _options$parseHtml = options.parseHtml,\n      parseHtml = _options$parseHtml === undefined ? defaultParseHtml : _options$parseHtml,\n      _options$rules = options.rules,\n      rules = _options$rules === undefined ? [] : _options$rules;\n  defaultBlock = Node.createProperties(defaultBlock);\n  this.rules = [].concat(toConsumableArray(rules), [TEXT_RULE]);\n  this.defaultBlock = defaultBlock;\n  this.parseHtml = parseHtml;\n};\n/**\n * Add a unique key to a React `element`.\n *\n * @param {Element} element\n * @return {Element}\n */\n\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.deserialize = function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$toJSON = options.toJSON,\n        toJSON = _options$toJSON === undefined ? false : _options$toJSON;\n    var defaultBlock = _this.defaultBlock,\n        parseHtml = _this.parseHtml;\n    var fragment = parseHtml(html);\n    var children = Array.from(fragment.childNodes);\n\n    var nodes = _this.deserializeElements(children); // COMPAT: ensure that all top-level inline nodes are wrapped into a block.\n\n\n    nodes = nodes.reduce(function (memo, node, i, original) {\n      if (node.object == 'block') {\n        memo.push(node);\n        return memo;\n      }\n\n      if (i > 0 && original[i - 1].object != 'block') {\n        var _block = memo[memo.length - 1];\n\n        _block.nodes.push(node);\n\n        return memo;\n      }\n\n      var block = _extends({\n        object: 'block',\n        data: {}\n      }, defaultBlock, {\n        nodes: [node]\n      });\n\n      memo.push(block);\n      return memo;\n    }, []); // TODO: pretty sure this is no longer needed.\n\n    if (nodes.length == 0) {\n      nodes = [_extends({\n        object: 'block',\n        data: {}\n      }, defaultBlock, {\n        nodes: [{\n          object: 'text',\n          leaves: [{\n            object: 'leaf',\n            text: '',\n            marks: []\n          }]\n        }]\n      })];\n    }\n\n    var json = {\n      object: 'value',\n      document: {\n        object: 'document',\n        data: {},\n        nodes: nodes\n      }\n    };\n    var ret = toJSON ? json : Value.fromJSON(json);\n    return ret;\n  };\n\n  this.deserializeElements = function () {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var nodes = [];\n    elements.filter(_this.cruftNewline).forEach(function (element) {\n      var node = _this.deserializeElement(element);\n\n      switch (typeOf(node)) {\n        case 'array':\n          nodes = nodes.concat(node);\n          break;\n\n        case 'object':\n          nodes.push(node);\n          break;\n      }\n    });\n    return nodes;\n  };\n\n  this.deserializeElement = function (element) {\n    var node = void 0;\n\n    if (!element.tagName) {\n      element.tagName = '';\n    }\n\n    var next = function next(elements) {\n      if (Object.prototype.toString.call(elements) == '[object NodeList]') {\n        elements = Array.from(elements);\n      }\n\n      switch (typeOf(elements)) {\n        case 'array':\n          return _this.deserializeElements(elements);\n\n        case 'object':\n          return _this.deserializeElement(elements);\n\n        case 'null':\n        case 'undefined':\n          return;\n\n        default:\n          throw new Error('The `next` argument was called with invalid children: \"' + elements + '\".');\n      }\n    };\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _this.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var rule = _step.value;\n        if (!rule.deserialize) continue;\n        var ret = rule.deserialize(element, next);\n        var type = typeOf(ret);\n\n        if (type != 'array' && type != 'object' && type != 'null' && type != 'undefined') {\n          throw new Error('A rule returned an invalid deserialized representation: \"' + node + '\".');\n        }\n\n        if (ret === undefined) {\n          continue;\n        } else if (ret === null) {\n          return null;\n        } else if (ret.object == 'mark') {\n          node = _this.deserializeMark(ret);\n        } else {\n          node = ret;\n        }\n\n        break;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return node || next(element.childNodes);\n  };\n\n  this.deserializeMark = function (mark) {\n    var type = mark.type,\n        data = mark.data;\n\n    var applyMark = function applyMark(node) {\n      if (node.object == 'mark') {\n        return _this.deserializeMark(node);\n      } else if (node.object == 'text') {\n        node.leaves = node.leaves.map(function (leaf) {\n          leaf.marks = leaf.marks || [];\n          leaf.marks.push({\n            type: type,\n            data: data\n          });\n          return leaf;\n        });\n      } else if (node.nodes) {\n        node.nodes = node.nodes.map(applyMark);\n      }\n\n      return node;\n    };\n\n    return mark.nodes.reduce(function (nodes, node) {\n      var ret = applyMark(node);\n      if (Array.isArray(ret)) return nodes.concat(ret);\n      nodes.push(ret);\n      return nodes;\n    }, []);\n  };\n\n  this.serialize = function (value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var document = value.document;\n    var elements = document.nodes.map(_this.serializeNode).filter(function (el) {\n      return el;\n    });\n    if (options.render === false) return elements;\n    var html = renderToStaticMarkup(React.createElement('body', null, elements));\n    var inner = html.slice(6, -7);\n    return inner;\n  };\n\n  this.serializeNode = function (node) {\n    if (node.object === 'text') {\n      var leaves = node.getLeaves();\n      return leaves.map(_this.serializeLeaf);\n    }\n\n    var children = node.nodes.map(_this.serializeNode);\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = _this.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var rule = _step2.value;\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(node, children);\n        if (ret === null) return;\n        if (ret) return addKey(ret);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    throw new Error('No serializer defined for node of type \"' + node.type + '\".');\n  };\n\n  this.serializeLeaf = function (leaf) {\n    var string = new String({\n      text: leaf.text\n    });\n\n    var text = _this.serializeString(string);\n\n    return leaf.marks.reduce(function (children, mark) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _this.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var rule = _step3.value;\n          if (!rule.serialize) continue;\n          var ret = rule.serialize(mark, children);\n          if (ret === null) return;\n          if (ret) return addKey(ret);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      throw new Error('No serializer defined for mark of type \"' + mark.type + '\".');\n    }, text);\n  };\n\n  this.serializeString = function (string) {\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = _this.rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var rule = _step4.value;\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(string, string.text);\n        if (ret) return ret;\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  };\n\n  this.cruftNewline = function (element) {\n    return !(element.nodeName === '#text' && element.nodeValue == '\\n');\n  };\n};\n\nvar key = 0;\n\nfunction addKey(element) {\n  return React.cloneElement(element, {\n    key: key++\n  });\n}\n\nexport default Html;","map":null,"metadata":{},"sourceType":"module"}