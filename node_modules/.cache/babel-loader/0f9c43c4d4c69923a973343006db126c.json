{"ast":null,"code":"\"use strict\";\n/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _a;\n\nvar deep_equal_1 = __importDefault(require(\"deep-equal\"));\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n/**\n * NO (None): No drop zone.\n *\n * Corners are counted clockwise, beginning top left\n * C1 (Corner top left): Position decided by top left corner function\n * C2 (Corner top right): Position decided by top right corner function\n * C3 (Corner bottom right): Position decided by bottom right corner function\n * C4 (Corner bottom left): Position decided by bottom left corner function\n *\n * Above:\n * AH (Above here): above, same level\n * AA (Above of self or some ancestor): Above, compute active level using classification functions, e.g. log, sin, mx + t\n *\n * Below:\n * BH (Below here)\n * BA (Below of self or some ancestor)\n *\n * Left of:\n * LH (Left of here)\n * LA (Left of self or some ancestor)\n *\n * Right of:\n * RH (Right of here)\n * RA (Right of self or some ancestor)\n *\n * Inside / inline\n * IL (Inline left)\n * IR (Inline right)\n */\n\n\nexports.classes = {\n  NO: 0,\n  C1: 10,\n  C2: 11,\n  C3: 12,\n  C4: 13,\n  AH: 200,\n  AA: 201,\n  BH: 210,\n  BA: 211,\n  LH: 220,\n  LA: 221,\n  RH: 230,\n  RA: 231,\n  IL: 300,\n  IR: 301\n};\nvar c = exports.classes;\n/**\n * A list of matrices that are used to define the callback function.\n *\n * @type {{6x6: *[], 10x10: *[], 10x10-no-inline: *[]}}\n */\n\nexports.defaultMatrices = {\n  '6x6': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.IL, c.AH, c.AH, c.IR, c.RA], [c.LA, c.LH, c.NO, c.NO, c.RH, c.RA], [c.LA, c.LH, c.NO, c.NO, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.C3]],\n  '10x10': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C1, c.C2, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C4, c.C3, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C4, c.BH, c.BH, c.C3, c.IR, c.RH, c.RA], [c.LA, c.LH, c.C4, c.BH, c.BH, c.BH, c.BH, c.C3, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.BH, c.BH, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.C3]],\n  '10x10-no-inline': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.C1, c.AH, c.AH, c.AH, c.AH, c.AH, c.AH, c.C2, c.RA], [c.LA, c.LH, c.C1, c.AH, c.AH, c.AH, c.AH, c.C2, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C1, c.AH, c.AH, c.C2, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C1, c.C2, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C4, c.C3, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C4, c.BH, c.BH, c.C3, c.RH, c.RH, c.RA], [c.LA, c.LH, c.C4, c.BH, c.BH, c.BH, c.BH, c.C3, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.BH, c.BH, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.C3]]\n};\n/**\n * Computes the average width and height for cells in a room.\n *\n * @param room\n * @param matrix\n * @returns {{x: number, y: number}}\n */\n\nexports.getRoomScale = function (_a) {\n  var room = _a.room,\n      matrix = _a.matrix;\n  var rows = matrix.length;\n  var cells = matrix[0].length;\n  var scalingX = room.width / cells;\n  var scalingY = room.height / rows;\n  return {\n    x: scalingX,\n    y: scalingY\n  };\n};\n/**\n * Returns the index of the hover cell.\n *\n * @param mouse\n * @param scale\n */\n\n\nexports.getMouseHoverCell = function (_a) {\n  var mouse = _a.mouse,\n      scale = _a.scale;\n  return {\n    cell: Math.floor(mouse.x / scale.x),\n    row: Math.floor(mouse.y / scale.y)\n  };\n};\n/**\n * Used for caching.\n */\n\n\nvar last = {\n  '10x10': null,\n  '10x10-no-inline': null\n};\n\nexports.computeHover = function (drag, hover, actions, _a, m // tslint:disable-next-line:no-any\n) {\n  var room = _a.room,\n      mouse = _a.mouse,\n      matrix = _a.matrix,\n      callbacks = _a.callbacks;\n  var scale = exports.getRoomScale({\n    room: room,\n    matrix: matrix\n  });\n  var hoverCell = exports.getMouseHoverCell({\n    mouse: mouse,\n    scale: scale\n  });\n  var rows = matrix.length;\n  var cells = matrix[0].length;\n\n  if (hoverCell.row >= rows) {\n    hoverCell.row = rows - 1;\n  } else if (hoverCell.row < 0) {\n    hoverCell.row = 0;\n  }\n\n  if (hoverCell.cell >= cells) {\n    hoverCell.cell = cells - 1;\n  } else if (hoverCell.cell < 0) {\n    hoverCell.cell = 0;\n  }\n\n  var cell = matrix[hoverCell.row][hoverCell.cell];\n\n  if (!callbacks[cell]) {\n    logger_1.default.error('Matrix callback not found.', {\n      room: room,\n      mouse: mouse,\n      matrix: matrix,\n      scale: scale,\n      hoverCell: hoverCell,\n      rows: rows,\n      cells: cells\n    });\n    return;\n  }\n\n  var all = {\n    item: drag.id,\n    hover: hover.id,\n    actions: actions,\n    ctx: {\n      room: room,\n      mouse: mouse,\n      position: hoverCell,\n      size: {\n        rows: rows,\n        cells: cells\n      },\n      scale: scale\n    }\n  };\n\n  if (deep_equal_1.default(all, last[m])) {\n    return;\n  }\n\n  last[m] = all;\n  return callbacks[cell](drag, hover, actions, {\n    room: room,\n    mouse: mouse,\n    position: hoverCell,\n    size: {\n      rows: rows,\n      cells: cells\n    },\n    scale: scale\n  });\n};\n/**\n * Return the mouse position relative to the cell.\n */\n\n\nexports.relativeMousePosition = function (_a) {\n  var mouse = _a.mouse,\n      position = _a.position,\n      scale = _a.scale;\n  return {\n    x: Math.round(mouse.x - position.cell * scale.x),\n    y: Math.round(mouse.y - position.row * scale.y)\n  };\n};\n/**\n * Computes the drop level based on the mouse position and the cell width.\n */\n\n\nexports.computeLevel = function (_a) {\n  var size = _a.size,\n      levels = _a.levels,\n      position = _a.position;\n\n  if (size <= (levels + 1) * 2) {\n    return Math.round(position / (size / levels));\n  }\n\n  var spare = size - (levels + 1) * 2;\n  var steps = [0];\n  var current = spare;\n\n  for (var i = 0; i <= levels; i++) {\n    steps.push(steps[i] + current / 2);\n    current /= 2;\n\n    if (position >= steps[i] + i * 2 && position < steps[i + 1] + (i + 1) * 2) {\n      return i;\n    }\n  }\n\n  return levels;\n};\n/**\n * Computes the horizontal drop level based on the mouse position.\n *\n * @param mouse\n * @param position\n * @param hover\n * @param scale\n * @param level\n * @param inv returns the inverse drop level. Usually true for left and above drop level computation.\n * @returns number\n */\n\n\nexports.computeHorizontal = function (_a, inv) {\n  var mouse = _a.mouse,\n      position = _a.position,\n      hover = _a.hover,\n      scale = _a.scale,\n      level = _a.level;\n\n  if (inv === void 0) {\n    inv = false;\n  }\n\n  var _b = hover.node.cells,\n      cells = _b === void 0 ? [] : _b;\n  var x = exports.relativeMousePosition({\n    mouse: mouse,\n    position: position,\n    scale: scale\n  }).x;\n  var at = exports.computeLevel({\n    size: scale.x,\n    position: x,\n    levels: level\n  });\n\n  if (cells.length) {\n    // Is row, always opt for lowest level\n    return level;\n  } // If the hovered element is an inline element, level 0 would be directly besides it which doesn't work.\n  // Set it to 1 instead.\n\n\n  if (hover.node.inline && at === 0) {\n    at = 1;\n  }\n\n  return inv ? level - at : at;\n};\n/**\n * Computes the vertical drop level based on the mouse position.\n *\n * @returns number\n */\n\n\nexports.computeVertical = function (_a, inv) {\n  var level = _a.level,\n      mouse = _a.mouse,\n      hover = _a.hover,\n      position = _a.position,\n      scale = _a.scale;\n\n  if (inv === void 0) {\n    inv = false;\n  }\n\n  var _b = hover.node.cells,\n      cells = _b === void 0 ? [] : _b;\n  var y = exports.relativeMousePosition({\n    mouse: mouse,\n    position: position,\n    scale: scale\n  }).y;\n  var at = exports.computeLevel({\n    size: scale.y,\n    position: y,\n    levels: level\n  });\n\n  if (cells.length) {\n    // Is row, always opt for lowest level\n    return level;\n  } // If the hovered element is an inline element, level 0 would be directly besides it which doesn't work.\n  // Set it to 1 instead.\n\n\n  if (hover.node.inline && at === 0) {\n    at = 1;\n  }\n\n  return inv ? level - at : at;\n};\n\nvar getDropLevel = function getDropLevel(hover) {\n  return hover.node.inline ? 1 : 0;\n};\n/**\n * A list of callbacks.\n */\n\n\nexports.defaultCallbacks = (_a = {}, _a[c.NO] = function (item, hover, _a) {\n  var clear = _a.clear;\n  return clear(item.id);\n},\n/* corners */\n_a[c.C1] = function (item, hover, _a, // tslint:disable-next-line:no-any\nctx) {\n  var leftOf = _a.leftOf,\n      above = _a.above;\n  var mouse = exports.relativeMousePosition(ctx);\n  var level = getDropLevel(hover);\n\n  if (mouse.x < mouse.y) {\n    return leftOf(item.rawNode(), hover.rawNode(), level);\n  }\n\n  above(item.rawNode(), hover.rawNode(), level);\n}, _a[c.C2] = function (item, hover, _a, // tslint:disable-next-line:no-any\nctx) {\n  var rightOf = _a.rightOf,\n      above = _a.above;\n  var mouse = exports.relativeMousePosition(ctx);\n  var level = getDropLevel(hover);\n\n  if (mouse.x > mouse.y) {\n    return rightOf(item.rawNode(), hover.rawNode(), level);\n  }\n\n  above(item.rawNode(), hover.rawNode(), level);\n}, _a[c.C3] = function (item, hover, _a, // tslint:disable-next-line:no-any\nctx) {\n  var rightOf = _a.rightOf,\n      below = _a.below;\n  var mouse = exports.relativeMousePosition(ctx);\n  var level = getDropLevel(hover);\n\n  if (mouse.x > mouse.y) {\n    return rightOf(item.rawNode(), hover.rawNode(), level);\n  }\n\n  below(item.rawNode(), hover.rawNode(), level);\n}, _a[c.C4] = function (item, hover, _a, // tslint:disable-next-line:no-any\nctx) {\n  var leftOf = _a.leftOf,\n      below = _a.below;\n  var mouse = exports.relativeMousePosition(ctx);\n  var level = getDropLevel(hover);\n\n  if (mouse.x < mouse.y) {\n    return leftOf(item.rawNode(), hover.rawNode(), level);\n  }\n\n  below(item.rawNode(), hover.rawNode(), level);\n},\n/* heres */\n_a[c.AH] = function (item, hover, _a) {\n  var above = _a.above;\n  var level = getDropLevel(hover);\n  above(item.rawNode(), __assign({}, hover.rawNode()), level);\n}, _a[c.BH] = function (item, hover, _a) {\n  var below = _a.below;\n  var level = getDropLevel(hover);\n  below(item.rawNode(), __assign({}, hover.rawNode()), level);\n}, _a[c.LH] = function (item, hover, _a) {\n  var leftOf = _a.leftOf;\n  var level = getDropLevel(hover);\n  leftOf(item.rawNode(), __assign({}, hover.rawNode()), level);\n}, _a[c.RH] = function (item, hover, _a) {\n  var rightOf = _a.rightOf;\n  var level = getDropLevel(hover);\n  rightOf(item.rawNode(), __assign({}, hover.rawNode()), level);\n},\n/* ancestors */\n_a[c.AA] = function (item, hover, _a, ctx) {\n  var above = _a.above;\n  return above(item.rawNode(), hover.rawNode(), exports.computeVertical(__assign({}, ctx, {\n    hover: hover,\n    level: hover.node.levels.above\n  }), true));\n}, _a[c.BA] = function (item, hover, _a, ctx) {\n  var below = _a.below;\n  return below(item.rawNode(), hover.rawNode(), exports.computeVertical(__assign({}, ctx, {\n    hover: hover,\n    level: hover.node.levels.below\n  })));\n}, _a[c.LA] = function (item, hover, _a, ctx) {\n  var leftOf = _a.leftOf;\n  return leftOf(item.rawNode(), hover.rawNode(), exports.computeHorizontal(__assign({}, ctx, {\n    hover: hover,\n    level: hover.node.levels.left\n  }), true));\n}, _a[c.RA] = function (item, hover, _a, ctx) {\n  var rightOf = _a.rightOf;\n  return rightOf(item.rawNode(), hover.rawNode(), exports.computeHorizontal(__assign({}, ctx, {\n    hover: hover,\n    level: hover.node.levels.right\n  })));\n},\n/* inline */\n_a[c.IL] = function (item, hover, _a) {\n  var inlineLeft = _a.inlineLeft,\n      leftOf = _a.leftOf;\n  var _b = hover.node,\n      inline = _b.inline,\n      hasInlineNeighbour = _b.hasInlineNeighbour;\n  var _c = item.node.content,\n      _d = (_c === void 0 ? {} : _c).plugin,\n      _e = (_d === void 0 ? {} : _d).isInlineable,\n      isInlineable = _e === void 0 ? false : _e;\n\n  if (inline || !isInlineable) {\n    return leftOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  if (hasInlineNeighbour && hasInlineNeighbour !== item.id) {\n    return leftOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  if (hasInlineNeighbour && hasInlineNeighbour === item.id && item.node.inline === 'left') {\n    return leftOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  inlineLeft(item.rawNode(), hover.rawNode());\n}, _a[c.IR] = function (item, hover, _a) {\n  var inlineRight = _a.inlineRight,\n      rightOf = _a.rightOf;\n  var _b = hover.node,\n      inline = _b.inline,\n      hasInlineNeighbour = _b.hasInlineNeighbour;\n  var _c = item.node.content,\n      _d = (_c === void 0 ? {} : _c).plugin,\n      _e = (_d === void 0 ? {} : _d).isInlineable,\n      isInlineable = _e === void 0 ? false : _e;\n\n  if (inline || !isInlineable) {\n    return rightOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  if (hasInlineNeighbour && hasInlineNeighbour !== item.id) {\n    return rightOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  if (hasInlineNeighbour && hasInlineNeighbour === item.id && item.node.inline === 'right') {\n    return rightOf(item.rawNode(), hover.rawNode(), 2);\n  }\n\n  inlineRight(item.rawNode(), hover.rawNode());\n}, _a);\n/**\n * The HoverService uses callbacks and matrices to compute hover logic.\n *\n * @class HoverService\n */\n\nvar HoverService =\n/** @class */\nfunction () {\n  function HoverService(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        matrices = _b.matrices,\n        callbacks = _b.callbacks;\n\n    this.callbacks = exports.defaultCallbacks;\n    this.matrices = exports.defaultMatrices;\n    this.matrices = matrices || this.matrices;\n    this.callbacks = callbacks || this.callbacks;\n  }\n\n  HoverService.prototype.hover = function (drag, hover, actions, _a) {\n    var room = _a.room,\n        mouse = _a.mouse,\n        _b = _a.matrix,\n        use = _b === void 0 ? '10x10' : _b;\n    return exports.computeHover(drag, hover, actions, {\n      room: room,\n      mouse: mouse,\n      matrix: this.matrices[use],\n      callbacks: this.callbacks\n    }, use);\n  };\n\n  return HoverService;\n}();\n\nexports.default = HoverService;","map":null,"metadata":{},"sourceType":"script"}