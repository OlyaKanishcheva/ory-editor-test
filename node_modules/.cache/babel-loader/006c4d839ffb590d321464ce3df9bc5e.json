{"ast":null,"code":"\"use strict\";\n/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar uuid_1 = require(\"uuid\");\n\nvar semver_1 = __importStar(require(\"semver\"));\n\nvar classes_1 = require(\"./classes\");\n\nvar default_1 = __importDefault(require(\"./default\"));\n\nvar missing_1 = require(\"./missing\");\n\nvar find = function find(name, version) {\n  if (version === void 0) {\n    version = '*';\n  }\n\n  return function (plugin) {\n    return plugin.name === name && semver_1.satisfies(plugin.version, version);\n  };\n};\n/**\n * Iterate through an editable content tree and generate ids where missing.\n */\n\n\nexports.generateMissingIds = function (props) {\n  var rows = props.rows,\n      cells = props.cells,\n      id = props.id;\n\n  if ((rows || []).length > 0) {\n    props.rows = rows.map(exports.generateMissingIds);\n  } else if ((cells || []).length > 0) {\n    props.cells = cells.map(exports.generateMissingIds);\n  }\n\n  return __assign({}, props, {\n    id: id || uuid_1.v4()\n  });\n};\n/**\n * PluginService is a registry of all content and layout plugins known to the editor.\n */\n\n\nvar PluginService =\n/** @class */\nfunction () {\n  /**\n   * Instantiate a new PluginService instance. You can provide your own set of content and layout plugins here.\n   */\n  function PluginService(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.content,\n        content = _c === void 0 ? [] : _c,\n        _d = _b.layout,\n        layout = _d === void 0 ? [] : _d,\n        native = _b.native;\n\n    var _this = this;\n\n    this.hasNativePlugin = function () {\n      return Boolean(_this.plugins.native);\n    };\n\n    this.getNativePlugin = function () {\n      return _this.plugins.native;\n    };\n\n    this.createNativePlugin = function ( // tslint:disable-next-line:no-any\n    hover, // tslint:disable-next-line:no-any\n    monitor, // tslint:disable-next-line:no-any\n    component) {\n      var native = _this.plugins.native;\n\n      if (!native) {\n        var insert_1 = new classes_1.NativePlugin({}); // tslint:disable-next-line:no-any\n\n        var cell = {\n          node: insert_1,\n          rawNode: function rawNode() {\n            return insert_1;\n          }\n        };\n        return cell;\n      } else {\n        var plugin = new classes_1.NativePlugin(native(hover, monitor, component));\n        var initialState = plugin.createInitialState(); // tslint:disable-next-line:no-any\n\n        var insert_2 = {\n          content: {\n            plugin: plugin,\n            state: initialState\n          }\n        };\n        /*if (plugin === 'layout') {\n          insert = { layout: { plugin, state: initialState } };\n        }*/\n        // tslint:disable-next-line:no-any\n\n        var cell = {\n          node: insert_2,\n          rawNode: function rawNode() {\n            return insert_2;\n          }\n        };\n        return cell;\n      }\n    };\n\n    this.setLayoutPlugins = function (plugins) {\n      if (plugins === void 0) {\n        plugins = [];\n      }\n\n      _this.plugins.layout = [];\n      plugins.forEach(function (plugin) {\n        return _this.addLayoutPlugin(plugin);\n      });\n    };\n\n    this.addLayoutPlugin = function (config) {\n      _this.plugins.layout.push(new classes_1.LayoutPlugin(config));\n    };\n\n    this.removeLayoutPlugin = function (name) {\n      _this.plugins.layout = _this.plugins.layout.filter(function (plugin) {\n        return plugin.name !== name;\n      });\n    };\n\n    this.setContentPlugins = function (plugins) {\n      if (plugins === void 0) {\n        plugins = [];\n      }\n\n      _this.plugins.content = []; // semicolon is required to avoid syntax error\n\n      [default_1.default].concat(plugins).forEach(function (plugin) {\n        return _this.addContentPlugin(plugin);\n      });\n    };\n\n    this.addContentPlugin = function (config) {\n      _this.plugins.content.push(new classes_1.ContentPlugin(config));\n    };\n\n    this.removeContentPlugin = function (name) {\n      _this.plugins.content = _this.plugins.content.filter(function (plugin) {\n        return plugin.name !== name;\n      });\n    };\n    /**\n     * Finds a layout plugin based on its name and version.\n     */\n\n\n    this.findLayoutPlugin = function (name, version) {\n      var plugin = _this.plugins.layout.find(find(name, version));\n\n      var pluginWrongVersion = undefined;\n\n      if (!plugin) {\n        pluginWrongVersion = _this.plugins.layout.find(find(name, '*'));\n      }\n\n      return {\n        plugin: plugin || new classes_1.LayoutPlugin(missing_1.layoutMissing({\n          name: name,\n          version: version\n        })),\n        pluginWrongVersion: pluginWrongVersion\n      };\n    };\n    /**\n     * Finds a content plugin based on its name and version.\n     */\n\n\n    this.findContentPlugin = function (name, version) {\n      var plugin = _this.plugins.content.find(find(name, version));\n\n      var pluginWrongVersion = undefined;\n\n      if (!plugin) {\n        pluginWrongVersion = _this.plugins.content.find(find(name, '*'));\n      }\n\n      return {\n        plugin: plugin || new classes_1.ContentPlugin(missing_1.contentMissing({\n          name: name,\n          version: version\n        })),\n        pluginWrongVersion: pluginWrongVersion\n      };\n    };\n    /**\n     * Returns a list of all known plugin names.\n     */\n\n\n    this.getRegisteredNames = function () {\n      return _this.plugins.content.map(function (_a) {\n        var name = _a.name;\n        return name;\n      }).concat(_this.plugins.layout.map(function (_a) {\n        var name = _a.name;\n        return name;\n      }));\n    };\n\n    this.migratePluginState = function ( // tslint:disable-next-line:no-any\n    state, plugin, dataVersion // tslint:disable-next-line:no-any\n    ) {\n      if (!plugin || !dataVersion || semver_1.default.valid(dataVersion) === null) {\n        return state;\n      }\n\n      var currentDataVersion = dataVersion;\n      var migrations = plugin.migrations ? plugin.migrations : [];\n\n      while (true) {\n        var migration = migrations.find(function (m) {\n          return semver_1.default.satisfies(currentDataVersion, m.fromVersionRange);\n        });\n        migrations = migrations.filter(function (m) {\n          return !semver_1.default.satisfies(currentDataVersion, m.fromVersionRange);\n        });\n\n        if (!migration) {\n          // We assume all migrations necessary for the current version of plugin to work are provided\n          // Therefore if we don't find any, that means we are done and state is up to date\n          break;\n        }\n\n        currentDataVersion = migration.toVersion;\n        state = migration.migrate(state);\n      }\n\n      return state;\n    }; // tslint:disable-next-line:no-any\n\n\n    this.getNewPluginState = function (found, state, version) {\n      if (!found.pluginWrongVersion || semver_1.default.lt(found.pluginWrongVersion.version, version)) {\n        // Standard case\n        return {\n          plugin: found.plugin,\n          state: found.plugin.unserialize(state)\n        };\n      } else {\n        // Attempt to migrate\n        var migratedState = _this.migratePluginState(state, found.pluginWrongVersion, version);\n\n        if (found.pluginWrongVersion && migratedState) {\n          return {\n            plugin: found.pluginWrongVersion,\n            state: found.pluginWrongVersion.unserialize(migratedState)\n          };\n        } else {\n          // Unable to migrate, fallback to missing plugin\n          return {\n            plugin: found.plugin,\n            state: found.plugin.unserialize(state)\n          };\n        }\n      }\n    }; // tslint:disable-next-line:no-any\n\n\n    this.unserialize = function (state) {\n      var _a = state.rows,\n          rows = _a === void 0 ? [] : _a,\n          _b = state.cells,\n          cells = _b === void 0 ? [] : _b,\n          _c = state.content,\n          content = _c === void 0 ? {} : _c,\n          _d = state.layout,\n          layout = _d === void 0 ? {} : _d,\n          inline = state.inline,\n          size = state.size,\n          id = state.id;\n      var newState = {\n        id: id,\n        inline: inline,\n        size: size\n      };\n\n      var _e = content || {},\n          _f = _e.plugin,\n          _g = _f === void 0 ? {} : _f,\n          _h = _g.name,\n          contentName = _h === void 0 ? null : _h,\n          _j = _g.version,\n          contentVersion = _j === void 0 ? '*' : _j,\n          _k = _e.state,\n          contentState = _k === void 0 ? {} : _k;\n\n      var _l = layout || {},\n          _m = _l.plugin,\n          _o = _m === void 0 ? {} : _m,\n          _p = _o.name,\n          layoutName = _p === void 0 ? null : _p,\n          _q = _o.version,\n          layoutVersion = _q === void 0 ? '*' : _q,\n          _r = _l.state,\n          layoutState = _r === void 0 ? {} : _r;\n\n      if (contentName) {\n        var found = _this.findContentPlugin(contentName, contentVersion);\n\n        var newContentState = _this.getNewPluginState(found, contentState, contentVersion);\n\n        newState.content = newContentState;\n      }\n\n      if (layoutName) {\n        var found = _this.findLayoutPlugin(layoutName, layoutVersion);\n\n        var newLayoutState = _this.getNewPluginState(found, layoutState, layoutVersion);\n\n        newState.layout = newLayoutState;\n      }\n\n      if ((rows || []).length) {\n        newState.rows = rows.map(_this.unserialize);\n      }\n\n      if ((cells || []).length) {\n        newState.cells = cells.map(_this.unserialize);\n      }\n\n      return exports.generateMissingIds(newState);\n    }; // tslint:disable-next-line:no-any\n\n\n    this.serialize = function (state) {\n      var _a = state.rows,\n          rows = _a === void 0 ? [] : _a,\n          _b = state.cells,\n          cells = _b === void 0 ? [] : _b,\n          content = state.content,\n          layout = state.layout,\n          inline = state.inline,\n          size = state.size,\n          id = state.id; // tslint:disable-next-line:no-any\n\n      var newState = {\n        id: id,\n        inline: inline,\n        size: size\n      };\n\n      if (content && content.plugin) {\n        newState.content = {\n          plugin: {\n            name: content.plugin.name,\n            version: content.plugin.version\n          },\n          state: content.plugin.serialize(content.state)\n        };\n      }\n\n      if (layout && layout.plugin) {\n        newState.layout = {\n          plugin: {\n            name: layout.plugin.name,\n            version: layout.plugin.version\n          },\n          state: layout.plugin.serialize(layout.state)\n        };\n      }\n\n      if (rows.length) {\n        newState.rows = rows.map(_this.serialize);\n      }\n\n      if (cells.length) {\n        newState.cells = cells.map(_this.serialize);\n      }\n\n      return newState;\n    };\n\n    this.plugins = {\n      content: [default_1.default].concat(content).map( // tslint:disable-next-line:no-any\n      function (config) {\n        return new classes_1.ContentPlugin(config);\n      }),\n      // tslint:disable-next-line:no-any\n      layout: layout.map(function (config) {\n        return new classes_1.LayoutPlugin(config);\n      }),\n      native: native\n    };\n  }\n\n  return PluginService;\n}();\n\nexports.default = PluginService;","map":null,"metadata":{},"sourceType":"script"}