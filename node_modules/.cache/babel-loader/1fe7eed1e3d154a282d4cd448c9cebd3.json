{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n/**\r\n * Create a schema definition with rules to normalize lists\r\n */\n\n\nfunction normalizeNode(opts) {\n  return function (node) {\n    return joinAdjacentLists(opts, node);\n  };\n}\n/**\r\n * A rule that joins adjacent lists of the same type\r\n */\n\n\nfunction joinAdjacentLists(opts, node) {\n  if (node.object !== 'document' && node.object !== 'block') {\n    return undefined;\n  }\n\n  var invalids = node.nodes.map(function (child, i) {\n    if (!utils_1.isList(opts)(child)) {\n      return null;\n    }\n\n    var next = node.nodes.get(i + 1);\n\n    if (!next || !utils_1.isList(opts)(next) || !opts.canMerge(child, next)) {\n      return null;\n    }\n\n    return [child, next];\n  }).filter(Boolean);\n\n  if (invalids.isEmpty()) {\n    return undefined;\n  }\n  /**\r\n   * Join the list pairs\r\n   */\n  // We join in reverse order, so that multiple lists folds onto the first one\n\n\n  return function (editor) {\n    invalids.reverse().forEach(function (pair) {\n      var _a = pair,\n          first = _a[0],\n          second = _a[1];\n      var updatedSecond = editor.value.document.getDescendant(second.key);\n      updatedSecond.nodes.forEach(function (secondNode, index) {\n        editor.withoutNormalizing(function () {\n          editor.moveNodeByKey(secondNode.key, first.key, first.nodes.size + index);\n        });\n      });\n      editor.withoutNormalizing(function () {\n        editor.removeNodeByKey(second.key);\n      });\n    });\n  };\n}\n\nexports.default = normalizeNode;","map":null,"metadata":{},"sourceType":"script"}