{"ast":null,"code":"\"use strict\";\n/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // tslint:disable-next-line:no-any\n\nvar nodeInner = function nodeInner(current, props) {\n  var id = current.id,\n      _a = current.rows,\n      rows = _a === void 0 ? [] : _a,\n      _b = current.cells,\n      cells = _b === void 0 ? [] : _b;\n\n  if (id === props.id) {\n    return current;\n  }\n\n  var found = undefined; // tslint:disable-next-line:no-any\n\n  rows.concat(cells).find(function (n) {\n    var f = nodeInner(n, props);\n\n    if (f) {\n      found = f;\n    }\n\n    return Boolean(f);\n  });\n  return found;\n};\n\nexports.editable = function (state, _a) {\n  var id = _a.id;\n  return state && state.ory && state.ory.editables && state.ory.editables.present.find(function (_a) {\n    var current = (_a === void 0 ? {} : _a).id;\n    return current === id;\n  });\n};\n\nexports.editables = function (_a) {\n  var present = _a.ory.editables.present;\n  return present;\n};\n\nexports.purifiedEditable = function (state, props) {\n  var found = exports.editable(state, props);\n\n  if (!found) {\n    return null;\n  }\n\n  return __assign({}, found, {\n    cells: (found.cells || []).map(function (c) {\n      return typeof c === 'string' ? c : c.id;\n    })\n  });\n};\n\nexports.editableConfig = function (state, _a) {\n  var id = _a.editable;\n  return exports.editable(state, {\n    id: id\n  }).config;\n};\n\nexports.node = function (state, props // tslint:disable-next-line:no-any\n) {\n  var tree = exports.editable(state, {\n    id: props.editable\n  });\n\n  if (!tree) {\n    throw new Error(\"Could not find editable: \" + props.editable);\n  }\n\n  return __assign({}, nodeInner(tree, props));\n};\n\nexports.searchNodeEverywhere = function (state, id) {\n  for (var i = 0; i < state.ory.editables.present.length; i++) {\n    var n = exports.node(state, {\n      id: id,\n      editable: state.ory.editables.present[i].id\n    });\n\n    if (n.id) {\n      return {\n        node: n,\n        editable: state.ory.editables.present[i]\n      };\n    }\n  }\n\n  return null;\n};\n\nexports.purifiedNode = function (state, props) {\n  var found = exports.node(state, props);\n\n  if (!found) {\n    return null;\n  }\n\n  if (found.cells) {\n    found.cells = found.cells.map(function (c) {\n      return c.id;\n    } // tslint:disable-next-line:no-any\n    );\n  }\n\n  if (found.rows) {\n    found.rows = found.rows.map(function (r) {\n      return r.id;\n    } // tslint:disable-next-line:no-any\n    );\n  }\n\n  return found;\n};","map":null,"metadata":{},"sourceType":"script"}