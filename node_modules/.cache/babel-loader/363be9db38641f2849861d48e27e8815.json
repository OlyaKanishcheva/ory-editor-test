{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar slate_1 = require(\"slate\");\n/**\r\n * Create a schema definition with rules to normalize blockquotes\r\n */\n\n\nfunction schema(opts) {\n  var _a;\n\n  return {\n    blocks: (_a = {}, _a[opts.type] = {\n      nodes: [{\n        match: {\n          type: opts.typeDefault\n        }\n      }],\n      // tslint:disable-next-line:no-any\n      normalize: function normalize(editor, error) {\n        switch (error.code) {\n          case 'child_type_invalid':\n            return containBlocks(opts, editor, error);\n\n          default:\n            break;\n        }\n      }\n    }, _a)\n  };\n}\n/**\r\n *  Ensures that blockquotes always contain blocks.\r\n */\n\n\nfunction containBlocks(opts, editor, // tslint:disable-next-line:no-any\ncontext) {\n  var toWrap = context.node.nodes.filter(function (n) {\n    return n.object !== 'block';\n  });\n\n  if (toWrap.isEmpty()) {\n    return undefined;\n  } // Wrap text/inline nodes in default block\n\n\n  var wrapper = slate_1.Block.create({\n    type: opts.typeDefault\n  });\n  return editor.withoutNormalizing(function () {\n    editor.insertNodeByKey(context.node.key, 0, wrapper);\n    toWrap.forEach(function (child, index) {\n      // this was use to determine normalization (isLast === false => normalize: false)\n      // const isLast = index === toWrap.size - 1;\n      editor.moveNodeByKey(child.key, wrapper.key, index);\n    });\n  });\n}\n\nexports.default = schema;","map":null,"metadata":{},"sourceType":"script"}