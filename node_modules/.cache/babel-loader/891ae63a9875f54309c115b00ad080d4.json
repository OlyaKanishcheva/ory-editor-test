{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Create a schema definition with rules to normalize lists\r\n */\n\nfunction schema(opts) {\n  var _a;\n\n  var constructedSchema = {\n    blocks: (_a = {}, _a[opts.typeItem] = {\n      parent: opts.types.map(function (t) {\n        return {\n          type: t\n        };\n      }),\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }],\n      normalize: normalize({\n        parent_type_invalid: function parent_type_invalid(editor, context) {\n          editor.withoutNormalizing(function () {\n            editor.unwrapNodeByKey(context.node.key);\n          });\n        },\n        child_object_invalid: function child_object_invalid(editor, context) {\n          wrapChildrenInDefaultBlock(opts, editor, context.node);\n        }\n      })\n    }, _a)\n  }; // validate all list types, ensure they only have list item children\n\n  opts.types.forEach(function (type) {\n    constructedSchema.blocks[type] = {\n      nodes: [{\n        match: {\n          type: opts.typeItem\n        }\n      }],\n      normalize: normalize({\n        child_type_invalid: function child_type_invalid(editor, context) {\n          editor.withoutNormalizing(function () {\n            editor.wrapBlockByKey(context.child.key, opts.typeItem);\n          });\n        }\n      })\n    };\n  });\n  return constructedSchema;\n}\n/*\r\n * Allows to define a normalize function through a keyed collection of functions\r\n */\n\n\nfunction normalize(reasons) {\n  // tslint:disable-next-line:no-any\n  return function (editor, error) {\n    var reasonFn = reasons[error.code];\n\n    if (reasonFn) {\n      reasonFn(editor, error);\n    }\n  };\n}\n/**\r\n * Wraps all child of a node in the default block type.\r\n * Returns a change, for chaining purposes\r\n */\n\n\nfunction wrapChildrenInDefaultBlock(opts, editor, node) {\n  editor.withoutNormalizing(function () {\n    editor.wrapBlockByKey(node.nodes.first().key, opts.typeDefault);\n  });\n  var wrapper = editor.value.document.getDescendant(node.key).nodes.first(); // Add in the remaining items\n\n  node.nodes.rest().forEach(function (child, index) {\n    editor.withoutNormalizing(function () {\n      editor.moveNodeByKey(child.key, wrapper.key, index + 1);\n    });\n  });\n  return editor;\n}\n\nexports.default = schema;","map":null,"metadata":{},"sourceType":"script"}